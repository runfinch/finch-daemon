// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

package tests

import (
	b64 "encoding/base64"
	"encoding/json"
	"fmt"
	"net/http"
	"os"
	"path/filepath"
	"time"

	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
	"github.com/onsi/gomega/gbytes"
	"github.com/runfinch/common-tests/command"
	"github.com/runfinch/common-tests/ffs"
	"github.com/runfinch/common-tests/fnet"
	"github.com/runfinch/common-tests/option"

	registrytypes "github.com/docker/docker/api/types/registry"
	"github.com/runfinch/finch-daemon/api/response"
	"github.com/runfinch/finch-daemon/e2e/client"
)

// DistributionInspect tests `GET distribution/{name:.*}` API.
func DistributionInspect(opt *option.Option) {
	Describe("inspect a distribution", func() {
		var (
			uClient      *http.Client
			version      string
			registry     string
			authImageTag string
		)
		BeforeEach(func() {
			// create a custom client to use http over unix sockets
			uClient = client.NewClient(GetDockerHostUrl())
			// get the docker api version that will be tested
			version = GetDockerApiVersion()
		})

		BeforeEach(func() {
			filename := "htpasswd"
			// The htpasswd is generated by
			// `<subject> run --entrypoint htpasswd public.ecr.aws/docker/library/httpd:2 -Bbn testUser testPassword`.
			// We don't want to generate it on the fly because:
			// 1. Pulling the httpd image can take a long time, sometimes even more 10 seconds.
			// 2. It's unlikely that we will have to update this in the future.
			// 3. It's not the thing we want to validate by the functional tests. We only want the output produced by it.
			// Same password/logic from runfinch/common-tests
			htpasswd := "testUser:$2y$05$wE0sj3r9O9K9q7R0MXcfPuIerl/06L1IsxXkCuUr3QZ8lHWwicIdS"
			htpasswdDir := filepath.Dir(ffs.CreateTempFile(filename, htpasswd))
			DeferCleanup(os.RemoveAll, htpasswdDir)
			port := fnet.GetFreePort()
			containerID := command.StdoutStr(opt, "run",
				"-dp", fmt.Sprintf("%d:5000", port),
				"--name", "registry",
				"-v", fmt.Sprintf("%s:/auth", htpasswdDir),
				"-e", "REGISTRY_AUTH=htpasswd",
				"-e", "REGISTRY_AUTH_HTPASSWD_REALM=Registry Realm",
				"-e", fmt.Sprintf("REGISTRY_AUTH_HTPASSWD_PATH=/auth/%s", filename),
				registryImage)
			// Wait for container to be running
			tries := 0
			for command.StdoutStr(opt, "inspect", "-f", "{{.State.Running}}", containerID) != "true" {
				if tries >= 5 {
					Fail("Registry container failed to start after 5 seconds")
				}
				time.Sleep(1 * time.Second)
				tries++
			}
			// Wait for registry service to be ready
			time.Sleep(10 * time.Second)
			registry = fmt.Sprintf(`localhost:%d`, port)
			authImageTag = fmt.Sprintf(`%s/test-login:tag`, registry)
			buildContext := ffs.CreateBuildContext(fmt.Sprintf(`FROM %s
	CMD ["echo", "bar"]
		`, defaultImage))
			DeferCleanup(os.RemoveAll, buildContext)
			command.Run(opt, "build", "-t", authImageTag, buildContext)
		})

		AfterEach(func() {
			command.RemoveAll(opt)
		})

		It("should inspect distribution of alpine image", func() {
			relativeUrl := client.ConvertToFinchUrl(version, fmt.Sprintf("/distribution/%s/json", newerAlpineImage))
			res, err := uClient.Get(relativeUrl)
			Expect(err).Should(BeNil())

			Expect(res).To(HaveHTTPStatus(http.StatusOK))
			var d registrytypes.DistributionInspect
			err = json.NewDecoder(res.Body).Decode(&d)
			Expect(err).Should(BeNil())
			Expect(d.Descriptor).ShouldNot(BeNil())
			Expect(d.Descriptor.MediaType).Should(Equal("application/vnd.oci.image.index.v1+json"))
			// since the image is built and pushed on the test runner, the following aspects are OS/architecture dependent
			// and not strictly checked
			Expect(d.Descriptor.Digest).Should(MatchRegexp(`sha256:\w{64}`))
			Expect(d.Descriptor.Size).Should(BeNumerically(">", 0))
			Expect(d.Descriptor.URLs).Should(HaveLen(0))
			Expect(d.Descriptor.Data).Should(BeNil())
			Expect(d.Descriptor.Platform).Should(BeNil())
			Expect(d.Descriptor.ArtifactType).Should(Equal(""))
			Expect(d.Platforms).ShouldNot(BeNil())
		})

		It("should inspect distribution of older alpine image", func() {
			relativeUrl := client.ConvertToFinchUrl(version, fmt.Sprintf("/distribution/%s/json", olderAlpineImage))
			res, err := uClient.Get(relativeUrl)
			Expect(err).Should(BeNil())

			Expect(res).To(HaveHTTPStatus(http.StatusOK))
			var d registrytypes.DistributionInspect
			err = json.NewDecoder(res.Body).Decode(&d)
			Expect(err).Should(BeNil())
			Expect(d.Descriptor).ShouldNot(BeNil())
			Expect(d.Descriptor.MediaType).Should(Equal("application/vnd.docker.distribution.manifest.list.v2+json"))
			// since the image is built and pushed on the test runner, the following aspects are OS/architecture dependent
			// and not strictly checked
			Expect(d.Descriptor.Digest).Should(MatchRegexp(`sha256:\w{64}`))
			Expect(d.Descriptor.Size).Should(BeNumerically(">", 0))
			Expect(d.Descriptor.URLs).Should(HaveLen(0))
			Expect(d.Descriptor.Data).Should(BeNil())
			Expect(d.Descriptor.Platform).Should(BeNil())
			Expect(d.Descriptor.ArtifactType).Should(Equal(""))
			Expect(d.Platforms).ShouldNot(BeNil())
		})

		It("should fail to inspect a non-existent image", func() {
			relativeUrl := client.ConvertToFinchUrl(version, fmt.Sprintf("/distribution/%s/json", nonexistentImageName))
			res, err := uClient.Get(relativeUrl)
			Expect(err).Should(BeNil())
			Expect(res).To(HaveHTTPStatus(http.StatusForbidden))

			var message response.Error
			err = json.NewDecoder(res.Body).Decode(&message)
			Expect(err).Should(BeNil())
			Expect(message.Message).Should(Equal("pull access denied, repository does not exist or " +
				"may require authorization: server message: insufficient_scope: authorization failed"))
		})

		It("should fail to inspect an image with a malformed image name", func() {
			malformedImage := "alpine:image:latest"
			relativeUrl := client.ConvertToFinchUrl(version, fmt.Sprintf("/distribution/%s/json", malformedImage))
			res, err := uClient.Get(relativeUrl)
			Expect(err).Should(BeNil())
			Expect(res).To(HaveHTTPStatus(http.StatusBadRequest))

			var message response.Error
			err = json.NewDecoder(res.Body).Decode(&message)
			Expect(err).Should(BeNil())
			Expect(message.Message).Should(Equal("invalid reference format"))
		})

		It("should inspect an image with registry credentials when logged in", func() {
			command.New(opt, "login", registry, "-u", testUser, "--password-stdin").
				WithStdin(gbytes.BufferWithBytes([]byte(testPassword))).Run()
			DeferCleanup(func() {
				command.Run(opt, "logout", registry)
			})
			command.Run(opt, "push", authImageTag)

			relativeUrl := client.ConvertToFinchUrl(version, fmt.Sprintf("/distribution/%s/json", authImageTag))

			req, err := http.NewRequest(http.MethodGet, relativeUrl, nil)
			Expect(err).Should(BeNil())
			req.Header.Set("X-Registry-Auth", b64.StdEncoding.EncodeToString([]byte(fmt.Sprintf(`{
  "username": "%s",
  "password": "%s",
  "serveraddress": "%s"
}`, testUser, testPassword, registry))))
			res, err := uClient.Do(req)
			Expect(err).Should(BeNil())

			Expect(res).To(HaveHTTPStatus(http.StatusOK))
			var d registrytypes.DistributionInspect
			err = json.NewDecoder(res.Body).Decode(&d)
			Expect(err).Should(BeNil())
			Expect(d.Descriptor).ShouldNot(BeNil())
			Expect(d.Descriptor.MediaType).Should(Equal("application/vnd.docker.distribution.manifest.v2+json"))
			// since the image is built and pushed on the test runner, the following aspects are OS/architecture dependent
			// and not strictly checked
			Expect(d.Descriptor.Digest).Should(MatchRegexp(`sha256:\w{64}`))
			Expect(d.Descriptor.Size).Should(BeNumerically(">", 0))
			Expect(d.Descriptor.URLs).Should(HaveLen(0))
			Expect(d.Descriptor.Data).Should(BeNil())
			Expect(d.Descriptor.Platform).Should(BeNil())
			Expect(d.Descriptor.ArtifactType).Should(Equal(""))
			Expect(d.Platforms).ShouldNot(BeNil())
		})

		It("should fail to inspect an image which needs registry credentials when not logged in", func() {
			command.New(opt, "login", registry, "-u", testUser, "--password-stdin").
				WithStdin(gbytes.BufferWithBytes([]byte(testPassword))).Run()
			command.Run(opt, "push", authImageTag)
			command.Run(opt, "logout", registry)

			relativeUrl := client.ConvertToFinchUrl(version, fmt.Sprintf("/distribution/%s/json", authImageTag))
			res, err := uClient.Get(relativeUrl)
			Expect(err).Should(BeNil())

			var message response.Error
			err = json.NewDecoder(res.Body).Decode(&message)
			Expect(err).Should(BeNil())
			Expect(message.Message).Should(And(
				ContainSubstring("pull access denied, repository does not exist or may require authorization"),
				ContainSubstring("no basic auth credentials"),
			))
		})
	})
}
