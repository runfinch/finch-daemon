// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

package tests

import (
	b64 "encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"path/filepath"
	"time"

	dockertypes "github.com/docker/cli/cli/config/types"
	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
	"github.com/onsi/gomega/gbytes"
	"github.com/runfinch/common-tests/command"
	"github.com/runfinch/common-tests/ffs"
	"github.com/runfinch/common-tests/fnet"
	"github.com/runfinch/common-tests/option"

	"github.com/runfinch/finch-daemon/e2e/client"
	"github.com/runfinch/finch-daemon/pkg/archive"
	"github.com/runfinch/finch-daemon/pkg/ecc"
	"github.com/runfinch/finch-daemon/pkg/flog"
)

func CredentialHelper(opt *option.Option, pOpt func([]string, ...option.Modifier) (*option.Option, error)) {
	Describe("credential helper with authenticated registry", func() {
		var (
			uClient       *http.Client
			version       string
			registry      string
			authImageTag  string
			buildContext  string
			testUser      = "testUser"
			testPassword  = "testPassword"
			registryImage = "public.ecr.aws/docker/library/registry:latest"
			defaultImage  = "public.ecr.aws/docker/library/alpine:latest"
		)

		BeforeEach(func() {
			command.RemoveAll(opt)
			uClient = client.NewClient(GetDockerHostUrl())
			version = GetDockerApiVersion()
		})

		BeforeEach(func() {
			filename := "htpasswd"
			// The htpasswd is generated by
			// `<subject> run --entrypoint htpasswd public.ecr.aws/docker/library/httpd:2 -Bbn testUser testPassword`.
			htpasswd := "testUser:$2y$05$wE0sj3r9O9K9q7R0MXcfPuIerl/06L1IsxXkCuUr3QZ8lHWwicIdS"
			htpasswdDir := filepath.Dir(ffs.CreateTempFile(filename, htpasswd))
			DeferCleanup(os.RemoveAll, htpasswdDir)

			// Set up authenticated registry
			port := fnet.GetFreePort()
			command.Run(opt, "run",
				"-dp", fmt.Sprintf("%d:5000", port),
				"--name", "registry",
				"-v", fmt.Sprintf("%s:/auth", htpasswdDir),
				"-e", "REGISTRY_AUTH=htpasswd",
				"-e", "REGISTRY_AUTH_HTPASSWD_REALM=Registry Realm",
				"-e", fmt.Sprintf("REGISTRY_AUTH_HTPASSWD_PATH=/auth/%s", filename),
				registryImage)
			registry = fmt.Sprintf(`localhost:%d`, port)

			command.Run(opt, "pull", defaultImage)

			authImageTag = fmt.Sprintf(`%s/test-login:tag`, registry)
			buildContext = ffs.CreateBuildContext(fmt.Sprintf(`FROM %s
	CMD ["echo", "credential-test"]
		`, defaultImage))
			DeferCleanup(os.RemoveAll, buildContext)

			command.Run(opt, "build", "-t", authImageTag, buildContext)

			command.New(opt, "login", registry, "-u", testUser, "--password-stdin").
				WithStdin(gbytes.BufferWithBytes([]byte(testPassword))).Run()
			DeferCleanup(func() {
				command.Run(opt, "logout", registry)
			})
			command.Run(opt, "push", authImageTag)
			command.Run(opt, "rmi", authImageTag)
		})

		AfterEach(func() {
			command.RemoveAll(opt)
		})

		It("should successfully build with registry credentials via API", func() {
			buildFromAuthImage := ffs.CreateBuildContext(fmt.Sprintf(`FROM %s
		CMD ["echo", "build-with-auth-successful"]
			`, authImageTag))
			DeferCleanup(os.RemoveAll, buildFromAuthImage)

			tarReader, err := createTarFromBuildContext(buildFromAuthImage)
			Expect(err).Should(BeNil())

			authConfig := map[string]dockertypes.AuthConfig{
				registry: {
					Username: testUser,
					Password: testPassword,
				},
			}

			authJSON, err := json.Marshal(authConfig)
			Expect(err).Should(BeNil())
			authHeader := b64.StdEncoding.EncodeToString(authJSON)

			resultTag := "result-image:latest"
			relativeUrl := client.ConvertToFinchUrl(version, "/build")
			req, err := http.NewRequest(http.MethodPost, relativeUrl, tarReader)
			Expect(err).Should(BeNil())

			req.Header.Set("Content-Type", "application/x-tar")
			req.Header.Set("X-Registry-Config", authHeader)

			q := req.URL.Query()
			q.Add("t", resultTag)
			req.URL.RawQuery = q.Encode()

			res, err := uClient.Do(req)
			Expect(err).Should(BeNil())
			defer res.Body.Close()

			respBody, err := io.ReadAll(res.Body)
			Expect(err).Should(BeNil())

			Expect(res).To(HaveHTTPStatus(http.StatusOK))
			Expect(string(respBody)).ShouldNot(ContainSubstring("error"))

			imageShouldExist(opt, resultTag)
		})

		It("should fail to build without registry credentials", func() {
			buildFromAuthImage := ffs.CreateBuildContext(fmt.Sprintf(`FROM %s
		CMD ["echo", "build-without-auth-should-fail"]
			`, authImageTag))
			DeferCleanup(os.RemoveAll, buildFromAuthImage)

			tarReader, err := createTarFromBuildContext(buildFromAuthImage)
			Expect(err).Should(BeNil())

			resultTag := "result-image:latest"
			relativeUrl := client.ConvertToFinchUrl(version, "/build")
			req, err := http.NewRequest(http.MethodPost, relativeUrl, tarReader)
			Expect(err).Should(BeNil())

			req.Header.Set("Content-Type", "application/x-tar")

			q := req.URL.Query()
			q.Add("t", resultTag)
			req.URL.RawQuery = q.Encode()

			res, err := uClient.Do(req)
			Expect(err).Should(BeNil())
			defer res.Body.Close()

			respBody, err := io.ReadAll(res.Body)
			Expect(err).Should(BeNil())

			Expect(res).To(HaveHTTPStatus(http.StatusInternalServerError))
			Expect(string(respBody)).Should(ContainSubstring(""))

			// Verify image was not built
			imageShouldNotExist(opt, resultTag)
		})

		It("should prevent credential sharing between parallel builds", func() {
			slowBuildContext := ffs.CreateBuildContext(fmt.Sprintf(`FROM %s
	RUN sleep 10
	CMD ["echo", "slow-build-with-auth-successful"]
		`, authImageTag))
			DeferCleanup(os.RemoveAll, slowBuildContext)

			fastBuildContext := ffs.CreateBuildContext(fmt.Sprintf(`FROM %s
	CMD ["echo", "quick-build-without-auth"]
		`, authImageTag))
			DeferCleanup(os.RemoveAll, fastBuildContext)

			slowTarReader, err := createTarFromBuildContext(slowBuildContext)
			Expect(err).Should(BeNil())
			quickTarReader, err := createTarFromBuildContext(fastBuildContext)
			Expect(err).Should(BeNil())

			authConfig := map[string]dockertypes.AuthConfig{
				registry: {
					Username: testUser,
					Password: testPassword,
				},
			}

			authJSON, err := json.Marshal(authConfig)
			Expect(err).Should(BeNil())
			authHeader := b64.StdEncoding.EncodeToString(authJSON)

			slowResultTag := "result-image-1:latest"
			slowUrl := client.ConvertToFinchUrl(version, "/build")
			slowReq, err := http.NewRequest(http.MethodPost, slowUrl, slowTarReader)
			Expect(err).Should(BeNil())

			slowReq.Header.Set("Content-Type", "application/x-tar")
			slowReq.Header.Set("X-Registry-Config", authHeader)

			slowQ := slowReq.URL.Query()
			slowQ.Add("t", slowResultTag)
			slowReq.URL.RawQuery = slowQ.Encode()

			quickResultTag := "result-image-2:latest"
			quickUrl := client.ConvertToFinchUrl(version, "/build")
			quickReq, err := http.NewRequest(http.MethodPost, quickUrl, quickTarReader)
			Expect(err).Should(BeNil())

			quickReq.Header.Set("Content-Type", "application/x-tar")

			quickQ := quickReq.URL.Query()
			quickQ.Add("t", quickResultTag)
			quickReq.URL.RawQuery = quickQ.Encode()

			// Start the slow build (with auth) in a goroutine to have creds in store.
			slowDone := make(chan struct{})
			var slowRes *http.Response
			var slowRespBody []byte
			var slowErr error

			go func() {
				defer close(slowDone)
				slowRes, slowErr = uClient.Do(slowReq)
				if slowErr == nil {
					defer slowRes.Body.Close()
					slowRespBody, _ = io.ReadAll(slowRes.Body)
				}
			}()

			time.Sleep(1 * time.Second)

			quickRes, err := uClient.Do(quickReq)
			Expect(err).Should(BeNil())
			defer quickRes.Body.Close()

			quickRespBody, err := io.ReadAll(quickRes.Body)
			Expect(err).Should(BeNil())

			Expect(quickRes).To(HaveHTTPStatus(http.StatusInternalServerError))
			Expect(string(quickRespBody)).Should(ContainSubstring(""))
			imageShouldNotExist(opt, quickResultTag)

			<-slowDone
			Expect(slowErr).Should(BeNil())
			Expect(slowRes).To(HaveHTTPStatus(http.StatusOK))
			Expect(string(slowRespBody)).ShouldNot(ContainSubstring("error"))

			imageShouldExist(opt, slowResultTag)
		})

		It("should return unauthorized error when requesting credentials from another parent process", func() {
			// Create a slow build that will run for a few seconds
			slowBuildContext := ffs.CreateBuildContext(fmt.Sprintf(`FROM %s
	RUN sleep 5
	CMD ["echo", "slow-build-for-credential-test"]
		`, defaultImage))
			DeferCleanup(os.RemoveAll, slowBuildContext)

			tarReader, err := createTarFromBuildContext(slowBuildContext)
			Expect(err).Should(BeNil())

			authConfig := map[string]dockertypes.AuthConfig{
				registry: {
					Username: testUser,
					Password: testPassword,
				},
			}

			authJSON, err := json.Marshal(authConfig)
			Expect(err).Should(BeNil())
			authHeader := b64.StdEncoding.EncodeToString(authJSON)

			slowResultTag := "result-image:latest"
			slowUrl := client.ConvertToFinchUrl(version, "/build")
			slowReq, err := http.NewRequest(http.MethodPost, slowUrl, tarReader)
			Expect(err).Should(BeNil())

			slowReq.Header.Set("Content-Type", "application/x-tar")
			slowReq.Header.Set("X-Registry-Config", authHeader)

			slowQ := slowReq.URL.Query()
			slowQ.Add("t", slowResultTag)
			slowReq.URL.RawQuery = slowQ.Encode()

			go func() {
				uClient.Timeout = 5 * time.Second
				client, _ := uClient.Do(slowReq)
				if client != nil {
					defer client.Body.Close()
				}
			}()

			time.Sleep(1 * time.Second)
			getCreds, _ := pOpt([]string{"sh", "-c", "echo \"serverurl\" | docker-credential-finch get"})
			getCreds.UpdateEnv("FINCH_BUILD_ID", "test")
			out := command.RunWithoutSuccessfulExit(getCreds).Out
			Expect(string(out.Contents())).Should(ContainSubstring("credentials not found in native keychain"))
		})

		It("should successfully build from a public registry image without authentication", func() {
			// Create a build context using a public registry image
			publicBuildContext := ffs.CreateBuildContext(fmt.Sprintf(`FROM %s
	CMD ["echo", "public-registry-image-build-successful"]
		`, defaultImage))
			DeferCleanup(os.RemoveAll, publicBuildContext)

			tarReader, err := createTarFromBuildContext(publicBuildContext)
			Expect(err).Should(BeNil())

			resultTag := "public-result-image:latest"
			relativeUrl := client.ConvertToFinchUrl(version, "/build")
			req, err := http.NewRequest(http.MethodPost, relativeUrl, tarReader)
			Expect(err).Should(BeNil())

			req.Header.Set("Content-Type", "application/x-tar")

			q := req.URL.Query()
			q.Add("t", resultTag)
			req.URL.RawQuery = q.Encode()

			res, err := uClient.Do(req)
			Expect(err).Should(BeNil())
			defer res.Body.Close()

			respBody, err := io.ReadAll(res.Body)
			Expect(err).Should(BeNil())

			Expect(res).To(HaveHTTPStatus(http.StatusOK))
			Expect(string(respBody)).ShouldNot(ContainSubstring("error"))

			// Verify the image was built successfully
			imageShouldExist(opt, resultTag)
		})
	})
}

// createTarFromBuildContext creates a tar archive from the build context directory.
func createTarFromBuildContext(buildContextPath string) (io.Reader, error) {
	logger := flog.NewLogrus()
	eccCreator := ecc.NewExecCmdCreator()
	tarCreator := archive.NewTarCreator(eccCreator, logger)

	cmd, err := tarCreator.CreateTarCommand(buildContextPath, true)
	if err != nil {
		return nil, err
	}

	pr, pw := io.Pipe()
	cmd.SetStdout(pw)

	go func() {
		err := cmd.Run()
		if err != nil {
			logger.Errorf("Error running tar command: %v", err)
		}
		pw.Close()
	}()

	return pr, nil
}
